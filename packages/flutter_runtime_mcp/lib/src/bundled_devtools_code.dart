// GENERATED FILE - DO NOT EDIT
// Generated by: dart run tool/generate_bundled_devtools.dart
// Source: packages/runtime_ai_dev_tools/lib/

/// Bundled imports for the synthetic main file
const String bundledImports = '''
// === Bundled runtime_ai_dev_tools imports ===
import 'dart:convert';
import 'dart:developer' as developer;
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
''';

/// Bundled runtime_ai_dev_tools code for the synthetic main file
const String bundledCode = r'''
// === Bundled runtime_ai_dev_tools code ===

// ============================================================================
// tap_visualization.dart
// ============================================================================

/// Singleton service to manage tap visualization overlays
class _TapVisualizationService {
  static final _TapVisualizationService _instance =
      _TapVisualizationService._internal();

  factory _TapVisualizationService() => _instance;

  _TapVisualizationService._internal();

  OverlayEntry? _currentOverlay;
  OverlayEntry? _persistentCursorOverlay;
  OverlayEntry? _scrollPathOverlay;
  OverlayEntry? _scrollEndIndicatorOverlay;
  GlobalKey<OverlayState>? _overlayKey;

  /// Register the overlay key from _DebugOverlayWrapper
  void setOverlayKey(GlobalKey<OverlayState> key) {
    _overlayKey = key;
    
  }

  /// Shows a tap visualization at the specified position
  void showTapAt(BuildContext context, double x, double y) {
    // Remove any existing overlay
    _currentOverlay?.remove();
    _currentOverlay = null;

    // Create new overlay entry
    _currentOverlay = OverlayEntry(
      builder: (context) => _TapVisualization(
        x: x,
        y: y,
        onComplete: () {
          _currentOverlay?.remove();
          _currentOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame to avoid interfering with event dispatch
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_currentOverlay != null) {
          // Use our custom overlay if available, otherwise fall back to context-based lookup
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_currentOverlay!);
          
        }
      } catch (e) {
        
      }
    });
  }

  /// Clears any active overlay
  void clear() {
    _currentOverlay?.remove();
    _currentOverlay = null;
  }

  /// Sets a persistent cursor at the specified position that stays visible until explicitly cleared
  /// This is useful for screenshots so the agent can see where the tap occurred
  void setPersistentCursor(BuildContext context, double x, double y) {
    // Remove any existing persistent cursor
    clearPersistentCursor();

    // Create new persistent cursor overlay
    _persistentCursorOverlay = OverlayEntry(
      builder: (context) => _PersistentCursor(x: x, y: y),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_persistentCursorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_persistentCursorOverlay!);
          
        }
      } catch (e) {
        
      }
    });
  }

  /// Clears the persistent cursor overlay
  void clearPersistentCursor() {
    _persistentCursorOverlay?.remove();
    _persistentCursorOverlay = null;
  }

  /// Shows an animated scroll path from start to end
  void showScrollPath(BuildContext context, Offset start, Offset end, Duration duration) {
    // Remove any existing scroll path overlay
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;

    // Create new overlay entry for scroll path animation
    _scrollPathOverlay = OverlayEntry(
      builder: (context) => _ScrollPathVisualization(
        start: start,
        end: end,
        duration: duration,
        onComplete: () {
          _scrollPathOverlay?.remove();
          _scrollPathOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollPathOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollPathOverlay!);
          
        }
      } catch (e) {
        
      }
    });
  }

  /// Sets a persistent indicator showing scroll start and end positions
  void setScrollEndIndicator(BuildContext context, Offset start, Offset end) {
    // Remove any existing scroll end indicator
    clearScrollEndIndicator();

    _scrollEndIndicatorOverlay = OverlayEntry(
      builder: (context) => _ScrollEndIndicator(start: start, end: end),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollEndIndicatorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollEndIndicatorOverlay!);
          
        }
      } catch (e) {
        
      }
    });
  }

  /// Clears the scroll end indicator overlay
  void clearScrollEndIndicator() {
    _scrollEndIndicatorOverlay?.remove();
    _scrollEndIndicatorOverlay = null;
  }

  /// Clears the scroll path overlay
  void clearScrollPath() {
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;
  }
}

/// Widget that displays the tap visualization animation
class _TapVisualization extends StatefulWidget {
  final double x;
  final double y;
  final VoidCallback onComplete;

  const _TapVisualization({
    required this.x,
    required this.y,
    required this.onComplete,
  });

  @override
  State<_TapVisualization> createState() => _TapVisualizationState();
}

class _TapVisualizationState extends State<_TapVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 100.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.6,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Stack(
            children: [
              Positioned(
                left: widget.x - _scaleAnimation.value / 2,
                top: widget.y - _scaleAnimation.value / 2,
                child: Container(
                  width: _scaleAnimation.value,
                  height: _scaleAnimation.value,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.blue.withValues(alpha: _opacityAnimation.value),
                      width: 2,
                    ),
                    color: Colors.blue.withValues(alpha: _opacityAnimation.value * 0.3),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

/// Widget that displays a persistent cursor indicator
/// This stays visible until explicitly cleared, useful for screenshots
class _PersistentCursor extends StatelessWidget {
  final double x;
  final double y;

  const _PersistentCursor({
    required this.x,
    required this.y,
  });

  static const double _innerDotSize = 8.0;
  static const double _crosshairLength = 20.0;
  static const double _crosshairThickness = 2.0;

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: Stack(
        children: [
          // Crosshair horizontal line
          Positioned(
            left: x - _crosshairLength / 2,
            top: y - _crosshairThickness / 2,
            child: Container(
              width: _crosshairLength,
              height: _crosshairThickness,
              color: Colors.deepOrange,
            ),
          ),
          // Crosshair vertical line
          Positioned(
            left: x - _crosshairThickness / 2,
            top: y - _crosshairLength / 2,
            child: Container(
              width: _crosshairThickness,
              height: _crosshairLength,
              color: Colors.deepOrange,
            ),
          ),
          // Center dot with border
          Positioned(
            left: x - _innerDotSize / 2,
            top: y - _innerDotSize / 2,
            child: Container(
              width: _innerDotSize,
              height: _innerDotSize,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.deepOrange,
                border: Border.all(
                  color: Colors.white,
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withValues(alpha: 0.3),
                    blurRadius: 2,
                    offset: const Offset(1, 1),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// Widget that displays an animated scroll path being drawn
class _ScrollPathVisualization extends StatefulWidget {
  final Offset start;
  final Offset end;
  final Duration duration;
  final VoidCallback onComplete;

  const _ScrollPathVisualization({
    required this.start,
    required this.end,
    required this.duration,
    required this.onComplete,
  });

  @override
  State<_ScrollPathVisualization> createState() => _ScrollPathVisualizationState();
}

class _ScrollPathVisualizationState extends State<_ScrollPathVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _progressAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();

    // Total animation: draw the line, then hold briefly, then fade
    final totalDuration = widget.duration + const Duration(milliseconds: 500);

    _controller = AnimationController(
      duration: totalDuration,
      vsync: this,
    );

    // Line drawing happens during the scroll duration
    final drawEndTime = widget.duration.inMilliseconds / totalDuration.inMilliseconds;
    _progressAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(0.0, drawEndTime, curve: Curves.linear),
    ));

    // Fade out happens after the line is drawn
    _fadeAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(drawEndTime, 1.0, curve: Curves.easeOut),
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return CustomPaint(
            size: Size.infinite,
            painter: _ScrollPathPainter(
              start: widget.start,
              end: widget.end,
              progress: _progressAnimation.value,
              opacity: _fadeAnimation.value,
            ),
          );
        },
      ),
    );
  }
}

/// Custom painter that draws an animated scroll path with arrow
class _ScrollPathPainter extends CustomPainter {
  final Offset start;
  final Offset end;
  final double progress;
  final double opacity;

  _ScrollPathPainter({
    required this.start,
    required this.end,
    required this.progress,
    required this.opacity,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (opacity <= 0) return;

    final paint = Paint()
      ..color = Colors.green.withValues(alpha: opacity * 0.8)
      ..strokeWidth = 4.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    // Calculate current end position based on progress
    final currentEnd = Offset(
      start.dx + (end.dx - start.dx) * progress,
      start.dy + (end.dy - start.dy) * progress,
    );

    // Draw the line
    canvas.drawLine(start, currentEnd, paint);

    // Draw start circle
    final circlePaint = Paint()
      ..color = Colors.green.withValues(alpha: opacity)
      ..style = PaintingStyle.fill;
    canvas.drawCircle(start, 6, circlePaint);

    // Draw arrowhead at current position if we have progress
    if (progress > 0.1) {
      _drawArrowhead(canvas, currentEnd, paint);
    }
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 12.0;
    const arrowAngle = 0.5; // radians

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    canvas.drawPath(arrowPath, paint);
  }

  @override
  bool shouldRepaint(_ScrollPathPainter oldDelegate) {
    return oldDelegate.progress != progress || oldDelegate.opacity != opacity;
  }
}

/// Widget that displays a persistent scroll end indicator
class _ScrollEndIndicator extends StatelessWidget {
  final Offset start;
  final Offset end;

  const _ScrollEndIndicator({
    required this.start,
    required this.end,
  });

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: CustomPaint(
        size: Size.infinite,
        painter: _ScrollEndPainter(start: start, end: end),
      ),
    );
  }
}

/// Custom painter for the persistent scroll indicator
class _ScrollEndPainter extends CustomPainter {
  final Offset start;
  final Offset end;

  _ScrollEndPainter({required this.start, required this.end});

  @override
  void paint(Canvas canvas, Size size) {
    // Draw line
    final linePaint = Paint()
      ..color = Colors.green.withValues(alpha: 0.6)
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawLine(start, end, linePaint);

    // Draw start circle (hollow)
    final startPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;
    canvas.drawCircle(start, 8, startPaint);

    // Draw end circle (filled)
    final endPaint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;
    canvas.drawCircle(end, 6, endPaint);

    // Draw arrow on line
    _drawArrowhead(canvas, end, linePaint);
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 14.0;
    const arrowAngle = 0.5;

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    final arrowPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawPath(arrowPath, arrowPaint);
  }

  @override
  bool shouldRepaint(_ScrollEndPainter oldDelegate) {
    return oldDelegate.start != start || oldDelegate.end != end;
  }
}

// Math functions for arrow drawing
double _bundledCos(double radians) => _cos(radians);
double _bundledSin(double radians) => _sin(radians);

double _cos(double x) {
  // Simple cosine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = 1.0;
  double term = 1.0;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i - 1) * (2 * i));
    result += term;
  }
  return result;
}

double _sin(double x) {
  // Simple sine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = x;
  double term = x;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i) * (2 * i + 1));
    result += term;
  }
  return result;
}

// ============================================================================
// screenshot_extension.dart
// ============================================================================

/// Registers the screenshot service extension
void _registerScreenshotExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.screenshot',
    (String method, Map<String, String> parameters) async {
                        try {
        final image = await _captureScreenshot();
        final base64Image = await _imageToBase64(image);

        // Get the device pixel ratio from the Flutter window
        final devicePixelRatio = WidgetsBinding.instance.platformDispatcher.views.first.devicePixelRatio;

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'image': base64Image,
            'devicePixelRatio': devicePixelRatio,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to capture screenshot: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Captures a screenshot of the root widget tree
Future<ui.Image> _captureScreenshot() async {
  final renderObject = WidgetsBinding.instance.rootElement?.findRenderObject();

  if (renderObject == null) {
    throw Exception('Root render object not found');
  }

  // Traverse up the tree to find a RenderRepaintBoundary
  RenderObject? current = renderObject;
  while (current != null && current is! RenderRepaintBoundary) {
    current = current.parent;
  }

  // If we found a RenderRepaintBoundary, use it
  if (current is RenderRepaintBoundary) {
    return await current.toImage(pixelRatio: 2.0);
  }

  // If no RenderRepaintBoundary found, use the layer approach
  // Get the layer from the render object and convert it to an image
  final layer = renderObject.debugLayer;
  if (layer == null) {
    throw Exception('No layer found on render object');
  }

  // Use the layer's buildScene to create an image
  final scene = layer.buildScene(ui.SceneBuilder());
  final image = await scene.toImage(
    renderObject.paintBounds.width.ceil(),
    renderObject.paintBounds.height.ceil(),
  );
  scene.dispose();

  return image;
}

/// Converts a UI image to base64-encoded PNG string
Future<String> _imageToBase64(ui.Image image) async {
  final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
  image.dispose();

  if (byteData == null) {
    throw Exception('Failed to convert image to byte data');
  }

  final buffer = byteData.buffer.asUint8List();
  return base64Encode(buffer);
}

// ============================================================================
// tap_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in tap gestures.
/// Each tap needs a unique pointer ID for Flutter's gesture system.
int _nextTapPointer = 1;

int _getNextTapPointer() {
  final result = _nextTapPointer;
  _nextTapPointer += 1;
  return result;
}

/// Registers the tap service extension
void _registerTapExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.tap',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final xStr = parameters['x'];
        final yStr = parameters['y'];

        if (xStr == null || yStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: x and y',
          );
        }

        final x = double.tryParse(xStr);
        final y = double.tryParse(yStr);

        if (x == null || y == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid x or y coordinate',
          );
        }

        await _simulateTap(x, y);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'x': xStr,
            'y': yStr,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate tap: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a tap at the specified coordinates
Future<void> _simulateTap(double x, double y) async {
  
  try {
    final binding = WidgetsBinding.instance;
    final offset = Offset(x, y);
    final pointer = _getNextTapPointer();
    
    // Show tap visualization first
    final rootContext = binding.rootElement;
    if (rootContext != null) {
            try {
        _TapVisualizationService().showTapAt(rootContext, x, y);
              } catch (e) {
                // Continue even if visualization fails
      }
    } else {
          }

    // Register the pointer device first
        final addEvent = PointerAddedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(addEvent);
    
    // Send pointer down event with unique pointer ID
        final downEvent = PointerDownEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(downEvent);
    
    // Wait 100ms for realistic tap duration
        await Future.delayed(const Duration(milliseconds: 100));

    // Send pointer up event with same pointer ID
        final upEvent = PointerUpEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(upEvent);
    
    // Unregister the pointer device
        final removeEvent = PointerRemovedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(removeEvent);
    
    // Set persistent cursor so screenshots show where the tap occurred
    if (rootContext != null) {
      try {
        _TapVisualizationService().setPersistentCursor(rootContext, x, y);
              } catch (e) {
                // Continue even if persistent cursor fails
      }
    }

      } catch (e, stackTrace) {
            rethrow;
  }
}

// ============================================================================
// type_extension.dart
// ============================================================================

/// Pattern to match special key sequences like {enter}, {ctrl+c}, {alt+shift+tab}
final _specialKeyPattern = RegExp(r'\{([^}]+)\}');

/// Registers the type service extension
void _registerTypeExtension() {
  

  developer.registerExtension(
    'ext.runtime_ai_dev_tools.type',
    (String method, Map<String, String> parameters) async {
      
      
      

      try {
        final text = parameters['text'];

        if (text == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameter: text',
          );
        }

        await _simulateTyping(text);

        return developer.ServiceExtensionResponse.result(
          json.encode({'status': 'success', 'text': text}),
        );
      } catch (e, stackTrace) {
        
        
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate typing: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates typing the given text with special key support.
///
/// Strategy:
/// 1. TextInputClient (covers TextField, xterm, etc.): Uses updateEditingValue()
/// 2. Fallback for Focus-based widgets: Raw key events
Future<void> _simulateTyping(String text) async {
  final tokens = _parseText(text);
  final textInputClient = _findTextInputClient();

  for (final token in tokens) {
    if (token.isSpecialKey) {
      await _handleSpecialKey(token.value);
    } else if (textInputClient != null) {
      await _insertViaTextInputClient(textInputClient, token.value);
    } else {
      // Fallback: raw key events for Focus-based widgets without TextInputClient
      for (final char in token.value.split('')) {
        await _simulateCharacterKeyPress(char);
        await Future.delayed(const Duration(milliseconds: 50));
      }
    }
  }
}

/// Find a TextInputClient in the widget tree from the focused element
TextInputClient? _findTextInputClient() {
  final focusNode = FocusManager.instance.primaryFocus;
  if (focusNode == null) return null;

  final context = focusNode.context;
  if (context == null) return null;

  TextInputClient? client;
  context.visitAncestorElements((element) {
    if (element is StatefulElement && element.state is TextInputClient) {
      client = element.state as TextInputClient;
      return false; // Stop visiting
    }
    return true; // Continue visiting
  });

  return client;
}

/// Insert text via TextInputClient (simulates platform text input)
/// This works for TextField, xterm, and any widget implementing TextInputClient.
Future<void> _insertViaTextInputClient(TextInputClient client, String text) async {
  final current = client.currentTextEditingValue ?? TextEditingValue.empty;
  final selection = current.selection;

  // Insert at cursor position if valid, otherwise append
  final newText = selection.isValid
      ? current.text.replaceRange(selection.start, selection.end, text)
      : current.text + text;

  final newCursorPosition =
      selection.isValid ? selection.start + text.length : newText.length;

  final newValue = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newCursorPosition),
  );

  client.updateEditingValue(newValue);
  await Future.delayed(const Duration(milliseconds: 50));
}

/// Parse text into tokens (regular text and special keys)
/// Special keys are patterns like {enter}, {ctrl+c}, {alt+shift+tab}, {f1}
List<_TypeToken> _parseText(String text) {
  final tokens = <_TypeToken>[];
  var lastEnd = 0;

  for (final match in _specialKeyPattern.allMatches(text)) {
    // Add any text before this match
    if (match.start > lastEnd) {
      tokens.add(_TypeToken(text.substring(lastEnd, match.start), isSpecialKey: false));
    }
    // Add the special key (the content inside {})
    tokens.add(_TypeToken(match.group(1)!, isSpecialKey: true));
    lastEnd = match.end;
  }

  // Add any remaining text after the last match
  if (lastEnd < text.length) {
    tokens.add(_TypeToken(text.substring(lastEnd), isSpecialKey: false));
  }

  return tokens;
}

/// Token representing either normal text or a special key
class _TypeToken {
  final String value;
  final bool isSpecialKey;

  _TypeToken(this.value, {required this.isSpecialKey});
}

/// Simulate a key press for a single character using raw key events
Future<void> _simulateCharacterKeyPress(String char) async {
  final keyInfo = _getKeyInfoForCharacter(char);
  if (keyInfo == null) return;

  if (keyInfo.needsShift) {
    await _sendKeyDown(
      physicalKey: PhysicalKeyboardKey.shiftLeft,
      logicalKey: LogicalKeyboardKey.shiftLeft,
      character: null,
    );
    await Future.delayed(const Duration(milliseconds: 5));
  }

  await _sendKeyDown(
    physicalKey: keyInfo.physicalKey,
    logicalKey: keyInfo.logicalKey,
    character: char,
  );
  await Future.delayed(const Duration(milliseconds: 10));
  await _sendKeyUp(
    physicalKey: keyInfo.physicalKey,
    logicalKey: keyInfo.logicalKey,
  );

  if (keyInfo.needsShift) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
      physicalKey: PhysicalKeyboardKey.shiftLeft,
      logicalKey: LogicalKeyboardKey.shiftLeft,
    );
  }
}

/// Handle special key actions via raw key events
/// Supports: {enter}, {ctrl+c}, {alt+shift+tab}, {cmd+s}, {f1}, etc.
Future<void> _handleSpecialKey(String keySpec) async {
  final parts = keySpec.toLowerCase().split('+');

  // Extract modifiers and the main key
  var ctrl = false;
  var alt = false;
  var shift = false;
  var meta = false; // cmd on macOS, win on Windows
  String? mainKey;

  for (final part in parts) {
    switch (part) {
      case 'ctrl':
      case 'control':
        ctrl = true;
        break;
      case 'alt':
      case 'option':
        alt = true;
        break;
      case 'shift':
        shift = true;
        break;
      case 'meta':
      case 'cmd':
      case 'command':
      case 'win':
      case 'super':
        meta = true;
        break;
      default:
        mainKey = part;
    }
  }

  if (mainKey == null) return;

  // Get the key info for the main key
  final keyInfo = _getSpecialKeyInfo(mainKey);
  if (keyInfo == null) return;

  // Press modifiers
  if (ctrl) {
    await _sendKeyDown(
      physicalKey: PhysicalKeyboardKey.controlLeft,
      logicalKey: LogicalKeyboardKey.controlLeft,
    );
  }
  if (alt) {
    await _sendKeyDown(
      physicalKey: PhysicalKeyboardKey.altLeft,
      logicalKey: LogicalKeyboardKey.altLeft,
    );
  }
  if (shift) {
    await _sendKeyDown(
      physicalKey: PhysicalKeyboardKey.shiftLeft,
      logicalKey: LogicalKeyboardKey.shiftLeft,
    );
  }
  if (meta) {
    await _sendKeyDown(
      physicalKey: PhysicalKeyboardKey.metaLeft,
      logicalKey: LogicalKeyboardKey.metaLeft,
    );
  }

  if (ctrl || alt || shift || meta) {
    await Future.delayed(const Duration(milliseconds: 5));
  }

  // Press main key
  await _sendKeyDown(
    physicalKey: keyInfo.physicalKey,
    logicalKey: keyInfo.logicalKey,
    character: keyInfo.character,
  );
  await Future.delayed(const Duration(milliseconds: 10));
  await _sendKeyUp(
    physicalKey: keyInfo.physicalKey,
    logicalKey: keyInfo.logicalKey,
  );

  // Release modifiers (in reverse order)
  if (meta) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
      physicalKey: PhysicalKeyboardKey.metaLeft,
      logicalKey: LogicalKeyboardKey.metaLeft,
    );
  }
  if (shift) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
      physicalKey: PhysicalKeyboardKey.shiftLeft,
      logicalKey: LogicalKeyboardKey.shiftLeft,
    );
  }
  if (alt) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
      physicalKey: PhysicalKeyboardKey.altLeft,
      logicalKey: LogicalKeyboardKey.altLeft,
    );
  }
  if (ctrl) {
    await Future.delayed(const Duration(milliseconds: 5));
    await _sendKeyUp(
      physicalKey: PhysicalKeyboardKey.controlLeft,
      logicalKey: LogicalKeyboardKey.controlLeft,
    );
  }

  await Future.delayed(const Duration(milliseconds: 50));
}

/// Special key info including physical/logical keys and optional character
class _SpecialKeyInfo {
  final PhysicalKeyboardKey physicalKey;
  final LogicalKeyboardKey logicalKey;
  final String? character;

  const _SpecialKeyInfo(this.physicalKey, this.logicalKey, [this.character]);
}

/// Get key info for a special key name
_SpecialKeyInfo? _getSpecialKeyInfo(String key) {
  // Navigation keys
  switch (key) {
    case 'enter':
    case 'return':
      return _SpecialKeyInfo(PhysicalKeyboardKey.enter, LogicalKeyboardKey.enter, '\n');
    case 'tab':
      return _SpecialKeyInfo(PhysicalKeyboardKey.tab, LogicalKeyboardKey.tab, '\t');
    case 'backspace':
      return _SpecialKeyInfo(PhysicalKeyboardKey.backspace, LogicalKeyboardKey.backspace);
    case 'delete':
    case 'del':
      return _SpecialKeyInfo(PhysicalKeyboardKey.delete, LogicalKeyboardKey.delete);
    case 'escape':
    case 'esc':
      return _SpecialKeyInfo(PhysicalKeyboardKey.escape, LogicalKeyboardKey.escape);
    case 'space':
      return _SpecialKeyInfo(PhysicalKeyboardKey.space, LogicalKeyboardKey.space, ' ');

    // Arrow keys
    case 'left':
    case 'arrowleft':
      return _SpecialKeyInfo(PhysicalKeyboardKey.arrowLeft, LogicalKeyboardKey.arrowLeft);
    case 'right':
    case 'arrowright':
      return _SpecialKeyInfo(PhysicalKeyboardKey.arrowRight, LogicalKeyboardKey.arrowRight);
    case 'up':
    case 'arrowup':
      return _SpecialKeyInfo(PhysicalKeyboardKey.arrowUp, LogicalKeyboardKey.arrowUp);
    case 'down':
    case 'arrowdown':
      return _SpecialKeyInfo(PhysicalKeyboardKey.arrowDown, LogicalKeyboardKey.arrowDown);

    // Navigation
    case 'home':
      return _SpecialKeyInfo(PhysicalKeyboardKey.home, LogicalKeyboardKey.home);
    case 'end':
      return _SpecialKeyInfo(PhysicalKeyboardKey.end, LogicalKeyboardKey.end);
    case 'pageup':
    case 'pgup':
      return _SpecialKeyInfo(PhysicalKeyboardKey.pageUp, LogicalKeyboardKey.pageUp);
    case 'pagedown':
    case 'pgdn':
      return _SpecialKeyInfo(PhysicalKeyboardKey.pageDown, LogicalKeyboardKey.pageDown);
    case 'insert':
    case 'ins':
      return _SpecialKeyInfo(PhysicalKeyboardKey.insert, LogicalKeyboardKey.insert);

    // Function keys
    case 'f1':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f1, LogicalKeyboardKey.f1);
    case 'f2':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f2, LogicalKeyboardKey.f2);
    case 'f3':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f3, LogicalKeyboardKey.f3);
    case 'f4':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f4, LogicalKeyboardKey.f4);
    case 'f5':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f5, LogicalKeyboardKey.f5);
    case 'f6':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f6, LogicalKeyboardKey.f6);
    case 'f7':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f7, LogicalKeyboardKey.f7);
    case 'f8':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f8, LogicalKeyboardKey.f8);
    case 'f9':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f9, LogicalKeyboardKey.f9);
    case 'f10':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f10, LogicalKeyboardKey.f10);
    case 'f11':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f11, LogicalKeyboardKey.f11);
    case 'f12':
      return _SpecialKeyInfo(PhysicalKeyboardKey.f12, LogicalKeyboardKey.f12);
  }

  // Single letter/digit keys (for combos like ctrl+c, ctrl+z)
  if (key.length == 1) {
    final char = key;
    final code = char.codeUnitAt(0);

    // Letters a-z
    if (code >= 'a'.codeUnitAt(0) && code <= 'z'.codeUnitAt(0)) {
      final keyInfo = _getLowercaseLetterKey(char);
      if (keyInfo != null) {
        return _SpecialKeyInfo(keyInfo.physicalKey, keyInfo.logicalKey, char);
      }
    }

    // Digits 0-9
    if (code >= '0'.codeUnitAt(0) && code <= '9'.codeUnitAt(0)) {
      final keyInfo = _getDigitKey(char);
      if (keyInfo != null) {
        return _SpecialKeyInfo(keyInfo.physicalKey, keyInfo.logicalKey, char);
      }
    }
  }

  return null;
}

/// Send a key down event by directly dispatching to the Focus tree
Future<bool> _sendKeyDown({
  required PhysicalKeyboardKey physicalKey,
  required LogicalKeyboardKey logicalKey,
  String? character,
}) async {
  final primaryFocus = FocusManager.instance.primaryFocus;
  if (primaryFocus == null) return false;

  final keyEvent = KeyDownEvent(
    physicalKey: physicalKey,
    logicalKey: logicalKey,
    character: character,
    timeStamp: Duration.zero,
  );

  final onKeyEvent = primaryFocus.onKeyEvent;
  if (onKeyEvent != null) {
    final result = onKeyEvent(primaryFocus, keyEvent);
    // For widgets like xterm's CustomKeyboardListener, character insertion
    // happens in the onKeyEvent callback even if it returns ignored
    if (keyEvent.character != null && keyEvent.character!.isNotEmpty) {
      return true;
    }
    return result == KeyEventResult.handled;
  }

  // Fallback: send through HardwareKeyboard API
  return ServicesBinding.instance.keyEventManager.handleKeyData(
    ui.KeyData(
      type: ui.KeyEventType.down,
      physical: physicalKey.usbHidUsage,
      logical: logicalKey.keyId,
      timeStamp: Duration.zero,
      character: character,
      synthesized: true,
    ),
  );
}

/// Send a key up event by directly dispatching to the Focus tree
Future<bool> _sendKeyUp({
  required PhysicalKeyboardKey physicalKey,
  required LogicalKeyboardKey logicalKey,
}) async {
  final primaryFocus = FocusManager.instance.primaryFocus;
  if (primaryFocus == null) return false;

  final keyEvent = KeyUpEvent(
    physicalKey: physicalKey,
    logicalKey: logicalKey,
    timeStamp: Duration.zero,
  );

  final onKeyEvent = primaryFocus.onKeyEvent;
  if (onKeyEvent != null) {
    final result = onKeyEvent(primaryFocus, keyEvent);
    return result == KeyEventResult.handled;
  }

  // Fallback: send through HardwareKeyboard API
  return ServicesBinding.instance.keyEventManager.handleKeyData(
    ui.KeyData(
      type: ui.KeyEventType.up,
      physical: physicalKey.usbHidUsage,
      logical: logicalKey.keyId,
      timeStamp: Duration.zero,
      character: null,
      synthesized: true,
    ),
  );
}

/// Information about a key for a character
class _KeyInfo {
  final PhysicalKeyboardKey physicalKey;
  final LogicalKeyboardKey logicalKey;
  final bool needsShift;

  const _KeyInfo({
    required this.physicalKey,
    required this.logicalKey,
    this.needsShift = false,
  });
}

/// Get key information for a character
_KeyInfo? _getKeyInfoForCharacter(String char) {
  // Lowercase letters
  if (char.codeUnitAt(0) >= 'a'.codeUnitAt(0) &&
      char.codeUnitAt(0) <= 'z'.codeUnitAt(0)) {
    return _getLowercaseLetterKey(char);
  }

  // Uppercase letters
  if (char.codeUnitAt(0) >= 'A'.codeUnitAt(0) &&
      char.codeUnitAt(0) <= 'Z'.codeUnitAt(0)) {
    return _getUppercaseLetterKey(char);
  }

  // Digits
  if (char.codeUnitAt(0) >= '0'.codeUnitAt(0) &&
      char.codeUnitAt(0) <= '9'.codeUnitAt(0)) {
    return _getDigitKey(char);
  }

  // Space
  if (char == ' ') {
    return const _KeyInfo(
      physicalKey: PhysicalKeyboardKey.space,
      logicalKey: LogicalKeyboardKey.space,
    );
  }

  // Common punctuation and symbols
  return _getSymbolKey(char);
}

/// Get key info for lowercase letter
_KeyInfo? _getLowercaseLetterKey(String char) {
  final offset = char.codeUnitAt(0) - 'a'.codeUnitAt(0);
  final physical = _letterPhysicalKeys[offset];
  final logical = _letterLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(physicalKey: physical, logicalKey: logical);
}

/// Get key info for uppercase letter (needs shift)
_KeyInfo? _getUppercaseLetterKey(String char) {
  final lower = char.toLowerCase();
  final offset = lower.codeUnitAt(0) - 'a'.codeUnitAt(0);
  final physical = _letterPhysicalKeys[offset];
  final logical = _letterLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(
    physicalKey: physical,
    logicalKey: logical,
    needsShift: true,
  );
}

/// Get key info for digit
_KeyInfo? _getDigitKey(String char) {
  final offset = char.codeUnitAt(0) - '0'.codeUnitAt(0);
  final physical = _digitPhysicalKeys[offset];
  final logical = _digitLogicalKeys[offset];
  if (physical == null || logical == null) return null;
  return _KeyInfo(physicalKey: physical, logicalKey: logical);
}

/// Get key info for symbol
_KeyInfo? _getSymbolKey(String char) {
  // Unshifted symbols on US keyboard
  switch (char) {
    case '-':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.minus,
        logicalKey: LogicalKeyboardKey.minus,
      );
    case '=':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.equal,
        logicalKey: LogicalKeyboardKey.equal,
      );
    case '[':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketLeft,
        logicalKey: LogicalKeyboardKey.bracketLeft,
      );
    case ']':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketRight,
        logicalKey: LogicalKeyboardKey.bracketRight,
      );
    case '\\':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backslash,
        logicalKey: LogicalKeyboardKey.backslash,
      );
    case ';':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.semicolon,
        logicalKey: LogicalKeyboardKey.semicolon,
      );
    case "'":
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.quote,
        logicalKey: LogicalKeyboardKey.quoteSingle,
      );
    case '`':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backquote,
        logicalKey: LogicalKeyboardKey.backquote,
      );
    case ',':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.comma,
        logicalKey: LogicalKeyboardKey.comma,
      );
    case '.':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.period,
        logicalKey: LogicalKeyboardKey.period,
      );
    case '/':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.slash,
        logicalKey: LogicalKeyboardKey.slash,
      );
    // Shifted symbols
    case '!':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit1,
        logicalKey: LogicalKeyboardKey.exclamation,
        needsShift: true,
      );
    case '@':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit2,
        logicalKey: LogicalKeyboardKey.at,
        needsShift: true,
      );
    case '#':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit3,
        logicalKey: LogicalKeyboardKey.numberSign,
        needsShift: true,
      );
    case '\$':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit4,
        logicalKey: LogicalKeyboardKey.dollar,
        needsShift: true,
      );
    case '%':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit5,
        logicalKey: LogicalKeyboardKey.percent,
        needsShift: true,
      );
    case '^':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit6,
        logicalKey: LogicalKeyboardKey.caret,
        needsShift: true,
      );
    case '&':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit7,
        logicalKey: LogicalKeyboardKey.ampersand,
        needsShift: true,
      );
    case '*':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit8,
        logicalKey: LogicalKeyboardKey.asterisk,
        needsShift: true,
      );
    case '(':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit9,
        logicalKey: LogicalKeyboardKey.parenthesisLeft,
        needsShift: true,
      );
    case ')':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.digit0,
        logicalKey: LogicalKeyboardKey.parenthesisRight,
        needsShift: true,
      );
    case '_':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.minus,
        logicalKey: LogicalKeyboardKey.underscore,
        needsShift: true,
      );
    case '+':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.equal,
        logicalKey: LogicalKeyboardKey.add,
        needsShift: true,
      );
    case '{':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketLeft,
        logicalKey: LogicalKeyboardKey.braceLeft,
        needsShift: true,
      );
    case '}':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.bracketRight,
        logicalKey: LogicalKeyboardKey.braceRight,
        needsShift: true,
      );
    case '|':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backslash,
        logicalKey: LogicalKeyboardKey.bar,
        needsShift: true,
      );
    case ':':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.semicolon,
        logicalKey: LogicalKeyboardKey.colon,
        needsShift: true,
      );
    case '"':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.quote,
        logicalKey: LogicalKeyboardKey.quote,
        needsShift: true,
      );
    case '~':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.backquote,
        logicalKey: LogicalKeyboardKey.tilde,
        needsShift: true,
      );
    case '<':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.comma,
        logicalKey: LogicalKeyboardKey.less,
        needsShift: true,
      );
    case '>':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.period,
        logicalKey: LogicalKeyboardKey.greater,
        needsShift: true,
      );
    case '?':
      return const _KeyInfo(
        physicalKey: PhysicalKeyboardKey.slash,
        logicalKey: LogicalKeyboardKey.question,
        needsShift: true,
      );
    default:
      return null;
  }
}

/// Physical keys for letters a-z
const _letterPhysicalKeys = <int, PhysicalKeyboardKey>{
  0: PhysicalKeyboardKey.keyA,
  1: PhysicalKeyboardKey.keyB,
  2: PhysicalKeyboardKey.keyC,
  3: PhysicalKeyboardKey.keyD,
  4: PhysicalKeyboardKey.keyE,
  5: PhysicalKeyboardKey.keyF,
  6: PhysicalKeyboardKey.keyG,
  7: PhysicalKeyboardKey.keyH,
  8: PhysicalKeyboardKey.keyI,
  9: PhysicalKeyboardKey.keyJ,
  10: PhysicalKeyboardKey.keyK,
  11: PhysicalKeyboardKey.keyL,
  12: PhysicalKeyboardKey.keyM,
  13: PhysicalKeyboardKey.keyN,
  14: PhysicalKeyboardKey.keyO,
  15: PhysicalKeyboardKey.keyP,
  16: PhysicalKeyboardKey.keyQ,
  17: PhysicalKeyboardKey.keyR,
  18: PhysicalKeyboardKey.keyS,
  19: PhysicalKeyboardKey.keyT,
  20: PhysicalKeyboardKey.keyU,
  21: PhysicalKeyboardKey.keyV,
  22: PhysicalKeyboardKey.keyW,
  23: PhysicalKeyboardKey.keyX,
  24: PhysicalKeyboardKey.keyY,
  25: PhysicalKeyboardKey.keyZ,
};

/// Logical keys for letters a-z
const _letterLogicalKeys = <int, LogicalKeyboardKey>{
  0: LogicalKeyboardKey.keyA,
  1: LogicalKeyboardKey.keyB,
  2: LogicalKeyboardKey.keyC,
  3: LogicalKeyboardKey.keyD,
  4: LogicalKeyboardKey.keyE,
  5: LogicalKeyboardKey.keyF,
  6: LogicalKeyboardKey.keyG,
  7: LogicalKeyboardKey.keyH,
  8: LogicalKeyboardKey.keyI,
  9: LogicalKeyboardKey.keyJ,
  10: LogicalKeyboardKey.keyK,
  11: LogicalKeyboardKey.keyL,
  12: LogicalKeyboardKey.keyM,
  13: LogicalKeyboardKey.keyN,
  14: LogicalKeyboardKey.keyO,
  15: LogicalKeyboardKey.keyP,
  16: LogicalKeyboardKey.keyQ,
  17: LogicalKeyboardKey.keyR,
  18: LogicalKeyboardKey.keyS,
  19: LogicalKeyboardKey.keyT,
  20: LogicalKeyboardKey.keyU,
  21: LogicalKeyboardKey.keyV,
  22: LogicalKeyboardKey.keyW,
  23: LogicalKeyboardKey.keyX,
  24: LogicalKeyboardKey.keyY,
  25: LogicalKeyboardKey.keyZ,
};

/// Physical keys for digits 0-9
const _digitPhysicalKeys = <int, PhysicalKeyboardKey>{
  0: PhysicalKeyboardKey.digit0,
  1: PhysicalKeyboardKey.digit1,
  2: PhysicalKeyboardKey.digit2,
  3: PhysicalKeyboardKey.digit3,
  4: PhysicalKeyboardKey.digit4,
  5: PhysicalKeyboardKey.digit5,
  6: PhysicalKeyboardKey.digit6,
  7: PhysicalKeyboardKey.digit7,
  8: PhysicalKeyboardKey.digit8,
  9: PhysicalKeyboardKey.digit9,
};

/// Logical keys for digits 0-9
const _digitLogicalKeys = <int, LogicalKeyboardKey>{
  0: LogicalKeyboardKey.digit0,
  1: LogicalKeyboardKey.digit1,
  2: LogicalKeyboardKey.digit2,
  3: LogicalKeyboardKey.digit3,
  4: LogicalKeyboardKey.digit4,
  5: LogicalKeyboardKey.digit5,
  6: LogicalKeyboardKey.digit6,
  7: LogicalKeyboardKey.digit7,
  8: LogicalKeyboardKey.digit8,
  9: LogicalKeyboardKey.digit9,
};

// ============================================================================
// scroll_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in scroll gestures.
/// Starts high to avoid conflicts with tap pointer IDs.
int _nextScrollPointer = 10000;

int _getNextScrollPointer() {
  final result = _nextScrollPointer;
  _nextScrollPointer += 1;
  return result;
}

/// Registers the scroll service extension
void _registerScrollExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.scroll',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final startXStr = parameters['startX'];
        final startYStr = parameters['startY'];
        final dxStr = parameters['dx'];
        final dyStr = parameters['dy'];
        final durationMsStr = parameters['durationMs'];

        if (startXStr == null || startYStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: startX and startY',
          );
        }

        if (dxStr == null || dyStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: dx and dy',
          );
        }

        final startX = double.tryParse(startXStr);
        final startY = double.tryParse(startYStr);
        final dx = double.tryParse(dxStr);
        final dy = double.tryParse(dyStr);

        if (startX == null || startY == null || dx == null || dy == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid coordinate values',
          );
        }

        final durationMs = durationMsStr != null ? int.tryParse(durationMsStr) : 300;
        final duration = Duration(milliseconds: durationMs ?? 300);

        await _simulateScroll(
          startX: startX,
          startY: startY,
          dx: dx,
          dy: dy,
          duration: duration,
        );

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'startX': startX,
            'startY': startY,
            'dx': dx,
            'dy': dy,
            'durationMs': duration.inMilliseconds,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate scroll: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a scroll/drag gesture from start position with given delta
Future<void> _simulateScroll({
  required double startX,
  required double startY,
  required double dx,
  required double dy,
  required Duration duration,
}) async {
        
  final binding = WidgetsBinding.instance;
  final endX = startX + dx;
  final endY = startY + dy;
  final pointer = _getNextScrollPointer();
  
  // Show scroll visualization
  final rootContext = binding.rootElement;
  if (rootContext != null) {
        try {
      _TapVisualizationService().showScrollPath(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
        duration,
      );
    } catch (e) {
            // Continue even if visualization fails
    }
  }

  // Calculate steps based on duration (target ~16ms per step for smooth animation)
  final steps = (duration.inMilliseconds / 16).round().clamp(5, 60);
  final stepDelay = Duration(milliseconds: duration.inMilliseconds ~/ steps);

  
  // Register the pointer device first
    binding.handlePointerEvent(PointerAddedEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));
  
  // Pointer down at start with unique pointer ID
    binding.handlePointerEvent(PointerDownEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));

  // Move through interpolated positions
  for (var i = 1; i <= steps; i++) {
    await Future.delayed(stepDelay);

    final progress = i / steps;
    final currentX = startX + dx * progress;
    final currentY = startY + dy * progress;

    binding.handlePointerEvent(PointerMoveEvent(
      position: Offset(currentX, currentY),
      delta: Offset(dx / steps, dy / steps),
      pointer: pointer,
    ));
  }

  // Pointer up at end with same pointer ID
    binding.handlePointerEvent(PointerUpEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));

  // Unregister the pointer device
    binding.handlePointerEvent(PointerRemovedEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));
  
  // Set persistent indicator at end position for screenshots
  if (rootContext != null) {
    try {
      _TapVisualizationService().setScrollEndIndicator(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
      );
    } catch (e) {
          }
  }

  }

// ============================================================================
// debug_overlay_wrapper.dart
// ============================================================================

/// Wraps the app with a custom overlay for tap visualization
///
/// This widget creates its own overlay at the root of the widget tree,
/// giving us full control over tap visualization without relying on
/// Navigator's overlay or MaterialApp's overlay.
class _DebugOverlayWrapper extends StatefulWidget {
  final Widget child;

  const _DebugOverlayWrapper({
    super.key,
    required this.child,
  });

  @override
  State<_DebugOverlayWrapper> createState() => _DebugOverlayWrapperState();
}

class _DebugOverlayWrapperState extends State<_DebugOverlayWrapper> {
  final GlobalKey<OverlayState> _overlayKey = GlobalKey<OverlayState>();

  @override
  void initState() {
    super.initState();
    // Register our overlay with the tap visualization service
    _TapVisualizationService().setOverlayKey(_overlayKey);
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.ltr,
      child: Overlay(
        key: _overlayKey,
        initialEntries: [
          OverlayEntry(
            builder: (context) => widget.child,
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// debug_binding.dart
// ============================================================================

/// Custom binding that automatically wraps the root widget with _DebugOverlayWrapper.
///
/// This binding intercepts the widget attachment process to inject the debug overlay
/// without requiring modification of the user's main.dart.
///
/// Usage in synthetic main:
/// ```dart
/// void main() {
///   _DebugWidgetsFlutterBinding.ensureInitialized();
///   RuntimeAiDevTools.registerExtensions();
///   user_app.main();
/// }
/// ```
class _DebugWidgetsFlutterBinding extends WidgetsFlutterBinding {
  /// Track if we've already wrapped to avoid double-wrapping
  bool _hasWrapped = false;

  /// Override wrapWithDefaultView to inject _DebugOverlayWrapper BEFORE the View wrapper.
  /// This is called by runApp before scheduleAttachRootWidget.
  @override
  Widget wrapWithDefaultView(Widget rootWidget) {
        if (_hasWrapped) {
            return super.wrapWithDefaultView(rootWidget);
    }
    _hasWrapped = true;
        // Wrap the user's widget with _DebugOverlayWrapper, then let the default View wrapper handle it
    return super.wrapWithDefaultView(_DebugOverlayWrapper(child: rootWidget));
  }

  /// Returns an instance of [_DebugWidgetsFlutterBinding], creating and
  /// initializing it if necessary.
  ///
  /// MUST be called before runApp() to ensure this binding is used.
  static WidgetsBinding ensureInitialized() {
    
    // Check if a binding already exists using the safe pattern
    // BindingBase.debugBindingType() is safe even when no binding exists
    final WidgetsBinding? existingBinding;
    try {
      existingBinding = WidgetsBinding.instance;
          } catch (e) {
      // No binding initialized yet - this is expected for first call
            _DebugWidgetsFlutterBinding();
            return WidgetsBinding.instance;
    }

    // A binding already exists
    if (existingBinding is _DebugWidgetsFlutterBinding) {
            return existingBinding;
    }

    // Different binding exists - warn but return it
            return existingBinding;
  }
}
''';
