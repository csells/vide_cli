// GENERATED FILE - DO NOT EDIT
// Generated by: dart run tool/generate_bundled_devtools.dart
// Source: packages/runtime_ai_dev_tools/lib/

/// Bundled imports for the synthetic main file
const String bundledImports = '''
// === Bundled runtime_ai_dev_tools imports ===
import 'dart:convert';
import 'dart:developer' as developer;
import 'dart:ui' as ui;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:flutter/widgets.dart';
''';

/// Bundled runtime_ai_dev_tools code for the synthetic main file
const String bundledCode = r'''
// === Bundled runtime_ai_dev_tools code ===

// ============================================================================
// tap_visualization.dart
// ============================================================================

/// Singleton service to manage tap visualization overlays
class _TapVisualizationService {
  static final _TapVisualizationService _instance =
      _TapVisualizationService._internal();

  factory _TapVisualizationService() => _instance;

  _TapVisualizationService._internal();

  OverlayEntry? _currentOverlay;
  OverlayEntry? _persistentCursorOverlay;
  OverlayEntry? _scrollPathOverlay;
  OverlayEntry? _scrollEndIndicatorOverlay;
  GlobalKey<OverlayState>? _overlayKey;

  /// Register the overlay key from _DebugOverlayWrapper
  void setOverlayKey(GlobalKey<OverlayState> key) {
    _overlayKey = key;
      }

  /// Shows a tap visualization at the specified position
  void showTapAt(BuildContext context, double x, double y) {
    // Remove any existing overlay
    _currentOverlay?.remove();
    _currentOverlay = null;

    // Create new overlay entry
    _currentOverlay = OverlayEntry(
      builder: (context) => _TapVisualization(
        x: x,
        y: y,
        onComplete: () {
          _currentOverlay?.remove();
          _currentOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame to avoid interfering with event dispatch
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_currentOverlay != null) {
          // Use our custom overlay if available, otherwise fall back to context-based lookup
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_currentOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears any active overlay
  void clear() {
    _currentOverlay?.remove();
    _currentOverlay = null;
  }

  /// Sets a persistent cursor at the specified position that stays visible until explicitly cleared
  /// This is useful for screenshots so the agent can see where the tap occurred
  void setPersistentCursor(BuildContext context, double x, double y) {
    // Remove any existing persistent cursor
    clearPersistentCursor();

    // Create new persistent cursor overlay
    _persistentCursorOverlay = OverlayEntry(
      builder: (context) => _PersistentCursor(x: x, y: y),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_persistentCursorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_persistentCursorOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears the persistent cursor overlay
  void clearPersistentCursor() {
    _persistentCursorOverlay?.remove();
    _persistentCursorOverlay = null;
  }

  /// Shows an animated scroll path from start to end
  void showScrollPath(BuildContext context, Offset start, Offset end, Duration duration) {
    // Remove any existing scroll path overlay
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;

    // Create new overlay entry for scroll path animation
    _scrollPathOverlay = OverlayEntry(
      builder: (context) => _ScrollPathVisualization(
        start: start,
        end: end,
        duration: duration,
        onComplete: () {
          _scrollPathOverlay?.remove();
          _scrollPathOverlay = null;
        },
      ),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollPathOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollPathOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Sets a persistent indicator showing scroll start and end positions
  void setScrollEndIndicator(BuildContext context, Offset start, Offset end) {
    // Remove any existing scroll end indicator
    clearScrollEndIndicator();

    _scrollEndIndicatorOverlay = OverlayEntry(
      builder: (context) => _ScrollEndIndicator(start: start, end: end),
    );

    // Insert overlay after current frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      try {
        if (_scrollEndIndicatorOverlay != null) {
          final overlayState = _overlayKey?.currentState ?? Overlay.of(context);
          overlayState.insert(_scrollEndIndicatorOverlay!);
                  }
      } catch (e) {
              }
    });
  }

  /// Clears the scroll end indicator overlay
  void clearScrollEndIndicator() {
    _scrollEndIndicatorOverlay?.remove();
    _scrollEndIndicatorOverlay = null;
  }

  /// Clears the scroll path overlay
  void clearScrollPath() {
    _scrollPathOverlay?.remove();
    _scrollPathOverlay = null;
  }
}

/// Widget that displays the tap visualization animation
class _TapVisualization extends StatefulWidget {
  final double x;
  final double y;
  final VoidCallback onComplete;

  const _TapVisualization({
    required this.x,
    required this.y,
    required this.onComplete,
  });

  @override
  State<_TapVisualization> createState() => _TapVisualizationState();
}

class _TapVisualizationState extends State<_TapVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;

  @override
  void initState() {
    super.initState();

    _controller = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );

    _scaleAnimation = Tween<double>(
      begin: 0.0,
      end: 100.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _opacityAnimation = Tween<double>(
      begin: 0.6,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Stack(
            children: [
              Positioned(
                left: widget.x - _scaleAnimation.value / 2,
                top: widget.y - _scaleAnimation.value / 2,
                child: Container(
                  width: _scaleAnimation.value,
                  height: _scaleAnimation.value,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.blue.withValues(alpha: _opacityAnimation.value),
                      width: 2,
                    ),
                    color: Colors.blue.withValues(alpha: _opacityAnimation.value * 0.3),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

/// Widget that displays a persistent cursor indicator
/// This stays visible until explicitly cleared, useful for screenshots
class _PersistentCursor extends StatelessWidget {
  final double x;
  final double y;

  const _PersistentCursor({
    required this.x,
    required this.y,
  });

  static const double _innerDotSize = 8.0;
  static const double _crosshairLength = 20.0;
  static const double _crosshairThickness = 2.0;

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: Stack(
        children: [
          // Crosshair horizontal line
          Positioned(
            left: x - _crosshairLength / 2,
            top: y - _crosshairThickness / 2,
            child: Container(
              width: _crosshairLength,
              height: _crosshairThickness,
              color: Colors.deepOrange,
            ),
          ),
          // Crosshair vertical line
          Positioned(
            left: x - _crosshairThickness / 2,
            top: y - _crosshairLength / 2,
            child: Container(
              width: _crosshairThickness,
              height: _crosshairLength,
              color: Colors.deepOrange,
            ),
          ),
          // Center dot with border
          Positioned(
            left: x - _innerDotSize / 2,
            top: y - _innerDotSize / 2,
            child: Container(
              width: _innerDotSize,
              height: _innerDotSize,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.deepOrange,
                border: Border.all(
                  color: Colors.white,
                  width: 1.5,
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withValues(alpha: 0.3),
                    blurRadius: 2,
                    offset: const Offset(1, 1),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// Widget that displays an animated scroll path being drawn
class _ScrollPathVisualization extends StatefulWidget {
  final Offset start;
  final Offset end;
  final Duration duration;
  final VoidCallback onComplete;

  const _ScrollPathVisualization({
    required this.start,
    required this.end,
    required this.duration,
    required this.onComplete,
  });

  @override
  State<_ScrollPathVisualization> createState() => _ScrollPathVisualizationState();
}

class _ScrollPathVisualizationState extends State<_ScrollPathVisualization>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _progressAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();

    // Total animation: draw the line, then hold briefly, then fade
    final totalDuration = widget.duration + const Duration(milliseconds: 500);

    _controller = AnimationController(
      duration: totalDuration,
      vsync: this,
    );

    // Line drawing happens during the scroll duration
    final drawEndTime = widget.duration.inMilliseconds / totalDuration.inMilliseconds;
    _progressAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(0.0, drawEndTime, curve: Curves.linear),
    ));

    // Fade out happens after the line is drawn
    _fadeAnimation = Tween<double>(
      begin: 1.0,
      end: 0.0,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Interval(drawEndTime, 1.0, curve: Curves.easeOut),
    ));

    _controller.forward().then((_) {
      widget.onComplete();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return CustomPaint(
            size: Size.infinite,
            painter: _ScrollPathPainter(
              start: widget.start,
              end: widget.end,
              progress: _progressAnimation.value,
              opacity: _fadeAnimation.value,
            ),
          );
        },
      ),
    );
  }
}

/// Custom painter that draws an animated scroll path with arrow
class _ScrollPathPainter extends CustomPainter {
  final Offset start;
  final Offset end;
  final double progress;
  final double opacity;

  _ScrollPathPainter({
    required this.start,
    required this.end,
    required this.progress,
    required this.opacity,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (opacity <= 0) return;

    final paint = Paint()
      ..color = Colors.green.withValues(alpha: opacity * 0.8)
      ..strokeWidth = 4.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    // Calculate current end position based on progress
    final currentEnd = Offset(
      start.dx + (end.dx - start.dx) * progress,
      start.dy + (end.dy - start.dy) * progress,
    );

    // Draw the line
    canvas.drawLine(start, currentEnd, paint);

    // Draw start circle
    final circlePaint = Paint()
      ..color = Colors.green.withValues(alpha: opacity)
      ..style = PaintingStyle.fill;
    canvas.drawCircle(start, 6, circlePaint);

    // Draw arrowhead at current position if we have progress
    if (progress > 0.1) {
      _drawArrowhead(canvas, currentEnd, paint);
    }
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 12.0;
    const arrowAngle = 0.5; // radians

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    canvas.drawPath(arrowPath, paint);
  }

  @override
  bool shouldRepaint(_ScrollPathPainter oldDelegate) {
    return oldDelegate.progress != progress || oldDelegate.opacity != opacity;
  }
}

/// Widget that displays a persistent scroll end indicator
class _ScrollEndIndicator extends StatelessWidget {
  final Offset start;
  final Offset end;

  const _ScrollEndIndicator({
    required this.start,
    required this.end,
  });

  @override
  Widget build(BuildContext context) {
    return IgnorePointer(
      child: CustomPaint(
        size: Size.infinite,
        painter: _ScrollEndPainter(start: start, end: end),
      ),
    );
  }
}

/// Custom painter for the persistent scroll indicator
class _ScrollEndPainter extends CustomPainter {
  final Offset start;
  final Offset end;

  _ScrollEndPainter({required this.start, required this.end});

  @override
  void paint(Canvas canvas, Size size) {
    // Draw line
    final linePaint = Paint()
      ..color = Colors.green.withValues(alpha: 0.6)
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawLine(start, end, linePaint);

    // Draw start circle (hollow)
    final startPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;
    canvas.drawCircle(start, 8, startPaint);

    // Draw end circle (filled)
    final endPaint = Paint()
      ..color = Colors.green
      ..style = PaintingStyle.fill;
    canvas.drawCircle(end, 6, endPaint);

    // Draw arrow on line
    _drawArrowhead(canvas, end, linePaint);
  }

  void _drawArrowhead(Canvas canvas, Offset tip, Paint paint) {
    final direction = (end - start).direction;
    const arrowSize = 14.0;
    const arrowAngle = 0.5;

    final point1 = Offset(
      tip.dx - arrowSize * _bundledCos(direction - arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction - arrowAngle),
    );
    final point2 = Offset(
      tip.dx - arrowSize * _bundledCos(direction + arrowAngle),
      tip.dy - arrowSize * _bundledSin(direction + arrowAngle),
    );

    final arrowPath = Path()
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point1.dx, point1.dy)
      ..moveTo(tip.dx, tip.dy)
      ..lineTo(point2.dx, point2.dy);

    final arrowPaint = Paint()
      ..color = Colors.green
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    canvas.drawPath(arrowPath, arrowPaint);
  }

  @override
  bool shouldRepaint(_ScrollEndPainter oldDelegate) {
    return oldDelegate.start != start || oldDelegate.end != end;
  }
}

// Math functions for arrow drawing
double _bundledCos(double radians) => _cos(radians);
double _bundledSin(double radians) => _sin(radians);

double _cos(double x) {
  // Simple cosine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = 1.0;
  double term = 1.0;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i - 1) * (2 * i));
    result += term;
  }
  return result;
}

double _sin(double x) {
  // Simple sine using Taylor series approximation
  x = x % (2 * 3.14159265359);
  double result = x;
  double term = x;
  for (int i = 1; i <= 10; i++) {
    term *= -x * x / ((2 * i) * (2 * i + 1));
    result += term;
  }
  return result;
}

// ============================================================================
// screenshot_extension.dart
// ============================================================================

/// Registers the screenshot service extension
void _registerScreenshotExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.screenshot',
    (String method, Map<String, String> parameters) async {
                        try {
        final image = await _captureScreenshot();
        final base64Image = await _imageToBase64(image);

        // Get the device pixel ratio from the Flutter window
        final devicePixelRatio = WidgetsBinding.instance.platformDispatcher.views.first.devicePixelRatio;

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'image': base64Image,
            'devicePixelRatio': devicePixelRatio,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to capture screenshot: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Captures a screenshot of the root widget tree
Future<ui.Image> _captureScreenshot() async {
  final renderObject = WidgetsBinding.instance.rootElement?.findRenderObject();

  if (renderObject == null) {
    throw Exception('Root render object not found');
  }

  // Traverse up the tree to find a RenderRepaintBoundary
  RenderObject? current = renderObject;
  while (current != null && current is! RenderRepaintBoundary) {
    current = current.parent;
  }

  // If we found a RenderRepaintBoundary, use it
  if (current is RenderRepaintBoundary) {
    return await current.toImage(pixelRatio: 2.0);
  }

  // If no RenderRepaintBoundary found, use the layer approach
  // Get the layer from the render object and convert it to an image
  final layer = renderObject.debugLayer;
  if (layer == null) {
    throw Exception('No layer found on render object');
  }

  // Use the layer's buildScene to create an image
  final scene = layer.buildScene(ui.SceneBuilder());
  final image = await scene.toImage(
    renderObject.paintBounds.width.ceil(),
    renderObject.paintBounds.height.ceil(),
  );
  scene.dispose();

  return image;
}

/// Converts a UI image to base64-encoded PNG string
Future<String> _imageToBase64(ui.Image image) async {
  final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
  image.dispose();

  if (byteData == null) {
    throw Exception('Failed to convert image to byte data');
  }

  final buffer = byteData.buffer.asUint8List();
  return base64Encode(buffer);
}

// ============================================================================
// tap_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in tap gestures.
/// Each tap needs a unique pointer ID for Flutter's gesture system.
int _nextTapPointer = 1;

int _getNextTapPointer() {
  final result = _nextTapPointer;
  _nextTapPointer += 1;
  return result;
}

/// Registers the tap service extension
void _registerTapExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.tap',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final xStr = parameters['x'];
        final yStr = parameters['y'];

        if (xStr == null || yStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: x and y',
          );
        }

        final x = double.tryParse(xStr);
        final y = double.tryParse(yStr);

        if (x == null || y == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid x or y coordinate',
          );
        }

        await _simulateTap(x, y);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'x': xStr,
            'y': yStr,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate tap: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a tap at the specified coordinates
Future<void> _simulateTap(double x, double y) async {
  
  try {
    final binding = WidgetsBinding.instance;
    final offset = Offset(x, y);
    final pointer = _getNextTapPointer();
    
    // Show tap visualization first
    final rootContext = binding.rootElement;
    if (rootContext != null) {
            try {
        _TapVisualizationService().showTapAt(rootContext, x, y);
              } catch (e) {
                // Continue even if visualization fails
      }
    } else {
          }

    // Register the pointer device first
        final addEvent = PointerAddedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(addEvent);
    
    // Send pointer down event with unique pointer ID
        final downEvent = PointerDownEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(downEvent);
    
    // Wait 100ms for realistic tap duration
        await Future.delayed(const Duration(milliseconds: 100));

    // Send pointer up event with same pointer ID
        final upEvent = PointerUpEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(upEvent);
    
    // Unregister the pointer device
        final removeEvent = PointerRemovedEvent(position: offset, pointer: pointer);
    binding.handlePointerEvent(removeEvent);
    
    // Set persistent cursor so screenshots show where the tap occurred
    if (rootContext != null) {
      try {
        _TapVisualizationService().setPersistentCursor(rootContext, x, y);
              } catch (e) {
                // Continue even if persistent cursor fails
      }
    }

      } catch (e, stackTrace) {
            rethrow;
  }
}

// ============================================================================
// type_extension.dart
// ============================================================================

/// Special key escape sequences supported by the type extension
const _specialKeys = {
  '{backspace}',
  '{enter}',
  '{tab}',
  '{escape}',
  '{left}',
  '{right}',
  '{up}',
  '{down}',
};

/// Track current text input state
int? _currentClientId;
TextEditingValue? _currentValue;
bool _isHandlerInstalled = false;

/// Registers the type service extension
void _registerTypeExtension() {
  
  // Install the text input handler to track client state
  _installTextInputHandler();

  developer.registerExtension(
    'ext.runtime_ai_dev_tools.type',
    (String method, Map<String, String> parameters) async {
                              
      try {
        final text = parameters['text'];

        if (text == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameter: text',
          );
        }

        await _simulateTyping(text);

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'text': text,
            'finalText': _currentValue?.text ?? '',
          }),
        );
      } catch (e, stackTrace) {
                        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate typing: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Install a message handler to intercept text input channel messages
/// This allows us to track the current client ID and editing state
void _installTextInputHandler() {
  if (_isHandlerInstalled) return;
  _isHandlerInstalled = true;

  
  ServicesBinding.instance.defaultBinaryMessenger.setMessageHandler(
    SystemChannels.textInput.name,
    (ByteData? message) async {
      if (message != null) {
        try {
          final call = SystemChannels.textInput.codec.decodeMethodCall(message);

          switch (call.method) {
            case 'TextInput.setClient':
              final args = call.arguments as List<dynamic>;
              _currentClientId = args[0] as int;
                            break;
            case 'TextInput.setEditingState':
              _currentValue = TextEditingValue.fromJSON(
                Map<String, dynamic>.from(call.arguments as Map),
              );
                            break;
            case 'TextInput.clearClient':
                            _currentClientId = null;
              _currentValue = null;
              break;
          }
        } catch (e) {
                  }
      }

      // Return null - we're just observing, not intercepting
      return null;
    },
  );

  }

/// Simulates typing the given text character-by-character with special key support
Future<void> _simulateTyping(String text) async {
  
  final tokens = _parseText(text);
  
  for (final token in tokens) {
    if (token.isSpecialKey) {
            await _handleSpecialKey(token.value);
    } else {
      // Type each character individually
      for (final char in token.value.split('')) {
                await _insertCharacter(char);
        // Small delay between characters for visibility
        await Future.delayed(const Duration(milliseconds: 50));
      }
    }
  }

    }

/// Parse text into tokens (regular text and special keys)
List<_TypeToken> _parseText(String text) {
  final tokens = <_TypeToken>[];
  var currentIndex = 0;
  var normalText = StringBuffer();

  while (currentIndex < text.length) {
    // Check if this is the start of a special key
    var foundSpecialKey = false;
    for (final key in _specialKeys) {
      if (text.substring(currentIndex).toLowerCase().startsWith(key)) {
        // Save any accumulated normal text first
        if (normalText.isNotEmpty) {
          tokens.add(_TypeToken(normalText.toString(), isSpecialKey: false));
          normalText = StringBuffer();
        }
        // Add the special key token
        tokens.add(_TypeToken(key, isSpecialKey: true));
        currentIndex += key.length;
        foundSpecialKey = true;
        break;
      }
    }

    if (!foundSpecialKey) {
      normalText.write(text[currentIndex]);
      currentIndex++;
    }
  }

  // Don't forget any trailing normal text
  if (normalText.isNotEmpty) {
    tokens.add(_TypeToken(normalText.toString(), isSpecialKey: false));
  }

  return tokens;
}

/// Token representing either normal text or a special key
class _TypeToken {
  final String value;
  final bool isSpecialKey;

  _TypeToken(this.value, {required this.isSpecialKey});
}

/// Insert a single character at the current cursor position
Future<void> _insertCharacter(String char) async {
  // Get current state or use defaults
  final currentText = _currentValue?.text ?? '';
  final selection =
      _currentValue?.selection ??
      TextSelection.collapsed(offset: currentText.length);

  // Insert character at cursor position or replace selection
  final newText = currentText.replaceRange(selection.start, selection.end, char);
  final newOffset = selection.start + char.length;

  final newValue = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newOffset),
  );

  await _sendEditingState(newValue);
  _currentValue = newValue;
}

/// Handle special key actions
Future<void> _handleSpecialKey(String key) async {
  switch (key.toLowerCase()) {
    case '{backspace}':
      await _handleBackspace();
      break;
    case '{enter}':
      await _handleEnter();
      break;
    case '{tab}':
      await _insertCharacter('\t');
      break;
    case '{escape}':
      await _handleEscape();
      break;
    case '{left}':
      await _moveCursor(-1);
      break;
    case '{right}':
      await _moveCursor(1);
      break;
    case '{up}':
      await _moveCursorVertically(-1);
      break;
    case '{down}':
      await _moveCursorVertically(1);
      break;
  }
  // Small delay after special keys
  await Future.delayed(const Duration(milliseconds: 50));
}

/// Handle backspace - delete character before cursor or delete selection
Future<void> _handleBackspace() async {
  if (_currentValue == null) {
        return;
  }

  final text = _currentValue!.text;
  final selection = _currentValue!.selection;

  String newText;
  int newOffset;

  if (selection.isCollapsed && selection.start > 0) {
    // Delete character before cursor
    newText =
        text.substring(0, selection.start - 1) + text.substring(selection.start);
    newOffset = selection.start - 1;
      } else if (!selection.isCollapsed) {
    // Delete selected text
    newText = text.replaceRange(selection.start, selection.end, '');
    newOffset = selection.start;
      } else {
    // Cursor at start, nothing to delete
        return;
  }

  final newValue = TextEditingValue(
    text: newText,
    selection: TextSelection.collapsed(offset: newOffset),
  );

  await _sendEditingState(newValue);
  _currentValue = newValue;
}

/// Handle enter - insert newline or trigger action for single-line fields
Future<void> _handleEnter() async {
  // For now, just insert a newline character
  // In a more sophisticated implementation, we could check if this is a
  // single-line field and trigger TextInputAction.done instead
    await _insertCharacter('\n');

  // Also try to trigger the done action for single-line text fields
  // This helps with form submission
  await _performAction(TextInputAction.done);
}

/// Handle escape - typically clears focus
Future<void> _handleEscape() async {
    // Send hide action - this typically clears focus
  try {
    await ServicesBinding.instance.defaultBinaryMessenger.handlePlatformMessage(
      SystemChannels.textInput.name,
      SystemChannels.textInput.codec.encodeMethodCall(
        const MethodCall('TextInput.hide'),
      ),
      (ByteData? reply) {},
    );
  } catch (e) {
      }
}

/// Move cursor horizontally by delta positions
Future<void> _moveCursor(int delta) async {
  if (_currentValue == null) {
        return;
  }

  final text = _currentValue!.text;
  final selection = _currentValue!.selection;

  int newOffset;
  if (selection.isCollapsed) {
    newOffset = (selection.start + delta).clamp(0, text.length);
  } else {
    // If there's a selection, moving collapses it
    newOffset = delta < 0 ? selection.start : selection.end;
  }

  
  final newValue = TextEditingValue(
    text: text,
    selection: TextSelection.collapsed(offset: newOffset),
  );

  await _sendEditingState(newValue);
  _currentValue = newValue;
}

/// Move cursor vertically (for multiline text fields)
/// This is a simplified implementation that moves to start/end of text
Future<void> _moveCursorVertically(int delta) async {
  if (_currentValue == null) {
        return;
  }

  final text = _currentValue!.text;
  final selection = _currentValue!.selection;

  // Find current line boundaries
  final currentOffset = selection.isCollapsed ? selection.start : selection.end;

  // Find the start of the current line
  int lineStart = currentOffset;
  while (lineStart > 0 && text[lineStart - 1] != '\n') {
    lineStart--;
  }

  // Find the end of the current line
  int lineEnd = currentOffset;
  while (lineEnd < text.length && text[lineEnd] != '\n') {
    lineEnd++;
  }

  // Column position within the line
  final column = currentOffset - lineStart;

  int newOffset;
  if (delta < 0) {
    // Move up
    if (lineStart == 0) {
      // Already on first line, move to start
      newOffset = 0;
    } else {
      // Find the previous line
      int prevLineEnd = lineStart - 1; // Skip the newline
      int prevLineStart = prevLineEnd;
      while (prevLineStart > 0 && text[prevLineStart - 1] != '\n') {
        prevLineStart--;
      }
      // Move to same column or end of previous line
      final prevLineLength = prevLineEnd - prevLineStart;
      newOffset = prevLineStart + column.clamp(0, prevLineLength);
    }
  } else {
    // Move down
    if (lineEnd >= text.length) {
      // Already on last line, move to end
      newOffset = text.length;
    } else {
      // Find the next line
      int nextLineStart = lineEnd + 1; // Skip the newline
      int nextLineEnd = nextLineStart;
      while (nextLineEnd < text.length && text[nextLineEnd] != '\n') {
        nextLineEnd++;
      }
      // Move to same column or end of next line
      final nextLineLength = nextLineEnd - nextLineStart;
      newOffset = nextLineStart + column.clamp(0, nextLineLength);
    }
  }

  
  final newValue = TextEditingValue(
    text: text,
    selection: TextSelection.collapsed(offset: newOffset),
  );

  await _sendEditingState(newValue);
  _currentValue = newValue;
}

/// Perform a text input action (like done, next, etc.)
Future<void> _performAction(TextInputAction action) async {
  final clientId = _currentClientId ?? -1;

  
  try {
    await ServicesBinding.instance.defaultBinaryMessenger.handlePlatformMessage(
      SystemChannels.textInput.name,
      SystemChannels.textInput.codec.encodeMethodCall(
        MethodCall('TextInputClient.performAction', <dynamic>[
          clientId,
          action.toString(),
        ]),
      ),
      (ByteData? reply) {},
    );
  } catch (e) {
      }
}

/// Send a new editing state to the text input channel
Future<void> _sendEditingState(TextEditingValue value) async {
  // Use client ID -1 if we don't have one (works in debug mode)
  final clientId = _currentClientId ?? -1;

  
  try {
    await ServicesBinding.instance.defaultBinaryMessenger.handlePlatformMessage(
      SystemChannels.textInput.name,
      SystemChannels.textInput.codec.encodeMethodCall(
        MethodCall('TextInputClient.updateEditingState', <dynamic>[
          clientId,
          value.toJSON(),
        ]),
      ),
      (ByteData? reply) {},
    );
  } catch (e) {
        rethrow;
  }
}

// ============================================================================
// scroll_extension.dart
// ============================================================================

/// Counter for unique pointer IDs in scroll gestures.
/// Starts high to avoid conflicts with tap pointer IDs.
int _nextScrollPointer = 10000;

int _getNextScrollPointer() {
  final result = _nextScrollPointer;
  _nextScrollPointer += 1;
  return result;
}

/// Registers the scroll service extension
void _registerScrollExtension() {
  
  developer.registerExtension(
    'ext.runtime_ai_dev_tools.scroll',
    (String method, Map<String, String> parameters) async {
                  
      try {
        final startXStr = parameters['startX'];
        final startYStr = parameters['startY'];
        final dxStr = parameters['dx'];
        final dyStr = parameters['dy'];
        final durationMsStr = parameters['durationMs'];

        if (startXStr == null || startYStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: startX and startY',
          );
        }

        if (dxStr == null || dyStr == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Missing required parameters: dx and dy',
          );
        }

        final startX = double.tryParse(startXStr);
        final startY = double.tryParse(startYStr);
        final dx = double.tryParse(dxStr);
        final dy = double.tryParse(dyStr);

        if (startX == null || startY == null || dx == null || dy == null) {
          return developer.ServiceExtensionResponse.error(
            developer.ServiceExtensionResponse.invalidParams,
            'Invalid coordinate values',
          );
        }

        final durationMs = durationMsStr != null ? int.tryParse(durationMsStr) : 300;
        final duration = Duration(milliseconds: durationMs ?? 300);

        await _simulateScroll(
          startX: startX,
          startY: startY,
          dx: dx,
          dy: dy,
          duration: duration,
        );

        return developer.ServiceExtensionResponse.result(
          json.encode({
            'status': 'success',
            'startX': startX,
            'startY': startY,
            'dx': dx,
            'dy': dy,
            'durationMs': duration.inMilliseconds,
          }),
        );
      } catch (e, stackTrace) {
        return developer.ServiceExtensionResponse.error(
          developer.ServiceExtensionResponse.extensionError,
          'Failed to simulate scroll: $e\n$stackTrace',
        );
      }
    },
  );
}

/// Simulates a scroll/drag gesture from start position with given delta
Future<void> _simulateScroll({
  required double startX,
  required double startY,
  required double dx,
  required double dy,
  required Duration duration,
}) async {
        
  final binding = WidgetsBinding.instance;
  final endX = startX + dx;
  final endY = startY + dy;
  final pointer = _getNextScrollPointer();
  
  // Show scroll visualization
  final rootContext = binding.rootElement;
  if (rootContext != null) {
        try {
      _TapVisualizationService().showScrollPath(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
        duration,
      );
    } catch (e) {
            // Continue even if visualization fails
    }
  }

  // Calculate steps based on duration (target ~16ms per step for smooth animation)
  final steps = (duration.inMilliseconds / 16).round().clamp(5, 60);
  final stepDelay = Duration(milliseconds: duration.inMilliseconds ~/ steps);

  
  // Register the pointer device first
    binding.handlePointerEvent(PointerAddedEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));
  
  // Pointer down at start with unique pointer ID
    binding.handlePointerEvent(PointerDownEvent(
    position: Offset(startX, startY),
    pointer: pointer,
  ));

  // Move through interpolated positions
  for (var i = 1; i <= steps; i++) {
    await Future.delayed(stepDelay);

    final progress = i / steps;
    final currentX = startX + dx * progress;
    final currentY = startY + dy * progress;

    binding.handlePointerEvent(PointerMoveEvent(
      position: Offset(currentX, currentY),
      delta: Offset(dx / steps, dy / steps),
      pointer: pointer,
    ));
  }

  // Pointer up at end with same pointer ID
    binding.handlePointerEvent(PointerUpEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));

  // Unregister the pointer device
    binding.handlePointerEvent(PointerRemovedEvent(
    position: Offset(endX, endY),
    pointer: pointer,
  ));
  
  // Set persistent indicator at end position for screenshots
  if (rootContext != null) {
    try {
      _TapVisualizationService().setScrollEndIndicator(
        rootContext,
        Offset(startX, startY),
        Offset(endX, endY),
      );
    } catch (e) {
          }
  }

  }

// ============================================================================
// debug_overlay_wrapper.dart
// ============================================================================

/// Wraps the app with a custom overlay for tap visualization
///
/// This widget creates its own overlay at the root of the widget tree,
/// giving us full control over tap visualization without relying on
/// Navigator's overlay or MaterialApp's overlay.
class _DebugOverlayWrapper extends StatefulWidget {
  final Widget child;

  const _DebugOverlayWrapper({
    super.key,
    required this.child,
  });

  @override
  State<_DebugOverlayWrapper> createState() => _DebugOverlayWrapperState();
}

class _DebugOverlayWrapperState extends State<_DebugOverlayWrapper> {
  final GlobalKey<OverlayState> _overlayKey = GlobalKey<OverlayState>();

  @override
  void initState() {
    super.initState();
    // Register our overlay with the tap visualization service
    _TapVisualizationService().setOverlayKey(_overlayKey);
  }

  @override
  Widget build(BuildContext context) {
    return Directionality(
      textDirection: TextDirection.ltr,
      child: Overlay(
        key: _overlayKey,
        initialEntries: [
          OverlayEntry(
            builder: (context) => widget.child,
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// debug_binding.dart
// ============================================================================

/// Custom binding that automatically wraps the root widget with _DebugOverlayWrapper.
///
/// This binding intercepts the widget attachment process to inject the debug overlay
/// without requiring modification of the user's main.dart.
///
/// Usage in synthetic main:
/// ```dart
/// void main() {
///   _DebugWidgetsFlutterBinding.ensureInitialized();
///   RuntimeAiDevTools.registerExtensions();
///   user_app.main();
/// }
/// ```
class _DebugWidgetsFlutterBinding extends WidgetsFlutterBinding {
  /// Track if we've already wrapped to avoid double-wrapping
  bool _hasWrapped = false;

  /// Override wrapWithDefaultView to inject _DebugOverlayWrapper BEFORE the View wrapper.
  /// This is called by runApp before scheduleAttachRootWidget.
  @override
  Widget wrapWithDefaultView(Widget rootWidget) {
        if (_hasWrapped) {
            return super.wrapWithDefaultView(rootWidget);
    }
    _hasWrapped = true;
        // Wrap the user's widget with _DebugOverlayWrapper, then let the default View wrapper handle it
    return super.wrapWithDefaultView(_DebugOverlayWrapper(child: rootWidget));
  }

  /// Returns an instance of [_DebugWidgetsFlutterBinding], creating and
  /// initializing it if necessary.
  ///
  /// MUST be called before runApp() to ensure this binding is used.
  static WidgetsBinding ensureInitialized() {
    
    // Check if a binding already exists using the safe pattern
    // BindingBase.debugBindingType() is safe even when no binding exists
    final WidgetsBinding? existingBinding;
    try {
      existingBinding = WidgetsBinding.instance;
          } catch (e) {
      // No binding initialized yet - this is expected for first call
            _DebugWidgetsFlutterBinding();
            return WidgetsBinding.instance;
    }

    // A binding already exists
    if (existingBinding is _DebugWidgetsFlutterBinding) {
            return existingBinding;
    }

    // Different binding exists - warn but return it
            return existingBinding;
  }
}
''';
